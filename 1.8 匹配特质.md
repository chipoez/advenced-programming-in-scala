和`isInstanceOf`一样，也可以通过模式匹配来观察不透明类在运行时表示为底层类。但是在模式匹配下，可以更深入一些：可以获得与底层类的_引用_。下面是一个例子，Listing 1.4中定义的`City`类在运行时通过`String`表示，模式匹配可以用来获取使用`City`和`String`的_引用_:

```scala
City("Paris") match
  case s: String => s.charAt(0) //P
```

正如此例所述，一旦你通过模式匹配使用类模式把一个不透明类转为底层类的时候，你就能使用定义在底层类的方法。尽管不能在`City`中执行`CharAt`方法，但是把`City`转成底层类`String`就能执行此方法。在`City`类中，执行底层类`String`的方法问题不大，因为`String`是不可变的。但是围绕不透明类的这种实现，如果底层类是可变的，并且不透明类限制了底层类的状态变更时，会带来麻烦。在这种情况下，这种获取底层类引用的能力，会成为允许违背不透明类对底层类可变性限制的后门。