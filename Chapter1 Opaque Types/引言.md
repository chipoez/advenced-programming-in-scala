不透明类

类型（types）在编译时帮助你实现目标，而作为在Scala中最常见的定义类型的方式，类（classes）存在运行时性能开销。在JVM中，引用扩展（extend）了引用类（AnyRef）的实例分配于垃圾回收堆（heap）中。相反，而扩展了数值类（AnyVal）的实例，例如Int、Double，则位于栈上。有时堆上的实例仅仅是用一个AnyRef类简单包装了另一个AnyRef类，调用位于栈上的实例会比位于堆上的实例效率更高，因为此举能够避免这种调用。尽管这种运行时开销对应用性能的影响微乎其微，有时却也至关重要。这也是为什么有必要存在一种方式仅在编译时存在的类型，以确保运行时的零开销。Scala 3 引入了不透明类正是出于此目的。
