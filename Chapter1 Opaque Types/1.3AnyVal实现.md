正如在《Scala编程》中章节17.4中描述的，Scala允许定义新的`AnyVal`类型。这些类继承了`AnyVal`并且遵循特定的规定。首先，`AnyVal`必须包装一个且仅一个的底层实现类的实例。第二，`AnyVal`不能被继承，它们是隐式的final类。第三，只能在`AnyVal`中能够定义的成员只能是方法，不能在`AnyVal`中定义内部类，也不能定义字段（除非通过将底层的唯一类参数公开），也不能定义懒加载值。也可以混入特质，但是只能混入“通用”特质。“通用特质”继承自Any，只有成员方法，不含初始化方法。
无论如何，用户定义的`AnyVal`实例在运行时表现为它们的底层类，但是在特定场合，它们也会被装箱。装箱时，它们是`AnyVal`包装器类的实例。用户定义的`AnyVal`允许定义类型来减少运行时装箱开销，但是不能保证完全零开销。作为交换，`AnyVal`能够用在真正的零开销不能用的地方。

`AnyVal`编译时，如同`AnyRef`扩展了一些静态方法。对于任何一个在`AnyVal`中声明的并且不是继承于通用特质的方法（这种方法也被称为可扩展方法），编译器会创建静态方法，此静态方法会额外含有一个底层类型作为入参。编译器会尽可能地用底层类而不是`AnyVal`包装器类来表示实例。当实例以未装箱的形态存在时，调用实例的可扩展方法，实际上编译器会用上述的静态方法替换它，并且传入底层类作为参数。

`AnyVal`设计的目的是允许用户创造一个包装器类，像常规类一样运作，但有时可以用底层类表示，特别是它的可扩展方法执行的时候。这个特性的动机是在Scala2.10中添加隐式类。继承自`AnyVal`的隐式类在执行可扩展方法时永远不需要装箱。这是的Scala的隐式转换如同其他语言一样享有相同的性能。然而，在Scala3中，隐式类被特殊的扩展方法语法替代了，详见《Scala编程》22章。

`AnyVal`在许多情形下会被装箱。通用特质允许用户如同使用`AnyRef`类一样，通过抽象度更高的类使用`AnyVal`类，但是当`AnyVal`通过这种方式使用时，需要装箱。用户也可以重写`Any`和`AnyVal`中没有`final`修饰的方法像是`equals`、`hasCode`、`toString`，但是执行这些方法需要装箱。`AnyVal`的类型检查仍然如期望进行，在`isInstanceOf`调用时、类型构造器模式都会检查，但也都要求装箱。因为上述调用有可能发生在通过抽象类调用`AnyVal`的过程中，不论抽象类是否实例化为`AnyVal`，都需要装箱。例如，列表`List`的左折叠`foldLeft`类型参数实例化为一个`AnyVal`类，`AnyVal`实例作为左折叠的零参数（zero parameter）传入，传入的实例是要装箱的。另一个例子是当把`AnyVal`实例放入一个集合比如List中时，集合的每个元素都要装箱成`AnyVal`形式。就算底层是通过Java原生实现的数组也是如此，一个Java数组包含了Scala `AnyVal`，每个元素也会装箱。

总结一下，`AnyVal`能够避免在某些形况下的装箱，但是某些形况下不行，如果`AnyVal`实例在生命周期中被反复装箱拆箱，可能性能比对应的只装箱一次的`AnyRef`还差。用户定义的`AnyVal`通过隐式类成功隐式转换，可获得媲美其他语言扩展方法相近的效率，但是Scala仍然需要真正的零开销类型，Scala 3的答案是不透明类
