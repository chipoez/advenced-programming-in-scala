# 零开销类型的使用场景

零开销类型能够帮助你在编译时达成类型安全的目的，而不需要在运行时进行不必要的装箱以此影响性能。例如，如果一个方法的参数列表包含两个连续的字符串`String`，像是输入地址时的街道`Street`和城市`City`栏，你很容易把它们搞混。如果在调用方法的时候，你不小心把街道和城市弄反了，或者在需要填某个的时候使用了另一个，并不会报类型错误，因为它们都是`String`类型的。如果取而代之，你定义了两个不同的小类，分别对应了每个参数，当你混用时就会得到类型错误。一个零开销类型允许你定义两个类，`Street`和`City`，它们在编译时表现地像是包装了`String`类，但是在运行时则按照简单的未包装过的`String`类表示。

另一种零开销类的使用场景是测量单位。例如，想象你的代码要同时适配英尺和厘米，而处于性能考虑你使用双精度浮点类`Double`在运行时表示这两种单位。如果你在代码里用`Double`同时表示两个单位，你有可能在调用一个代表厘米的`Double`时方法内却是`Double`代表英尺，反过来也是如此。通过定义两个零开销的类型，一个表示英尺而另一个表示厘米，如果用混了，你在编译时就会得到类型错误的报错，但是运行时仍然按照`Double`处理。

一个稍有不同的零开销类的使用场景是“限缩类”`narrowed type`。这个类能够完全地被另一个类的子集的值表示。例如，假若对于一个特定的方法参数，只有正值的Int是有效的，你可以在编译时用一个零开销的类`PosInt`，而在运行时就是`Int`。此外，由于`PosInt`就是`Int`值的子集，`PosInt`也可以被视为`Int`类的子类。在需要Int的情形，`PosInt`也可以使用。这不仅对于定义一个零开销的子类有用，也可以用于在零开销类和其他类之间定义“子类关系”。Scala的不透明类能够让你同时实现二者。

最后，有时它可以用来把一个可变对象包装用接口包装，接口减少了底层可变的状态的暴露，把可变的状态缩减为单个，甚至是把可变的对象变得难以修改。例如Scala3中加入了`IArray`不透明类，基于Java的数组实现了不可变数组。`IArray[Int]`基本上提供了`Array[Int]`相同的接口，除了那些允许改变底层数组的方法。这种不透明类在JVM上为你提供了高效的不可变数组。
