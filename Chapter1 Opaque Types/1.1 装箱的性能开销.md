# 1.1 装箱的性能开销
通过审查源码预估性能是困难的，因为JVM的即时编译器的行为难以预料。即时编译器不仅根据代码，也根据应用运行的行为来做出决策。不过，尽管很难对Java字节码的性能一概而论，对装箱（boxing）的大体性能评估是可能的。

  术语“装箱”意思是在堆上为对象分配内存，而不是栈上。当方法被调用时，栈会增长，方法返回时，栈会压缩，栈内存就是如此地被持续重复使用。而在堆中，内存的管理则有些棘手，因为储存在堆上的对象，生命周期难以预计。在JVM中，堆是通过代际回收器（generational collector）进行垃圾回收（garbage collet，gc）的。这些回收期通过增加（incrementing）亦或是推进（bumping）一个指针来快速分配内存，当对象被分配内存时，堆增长，正如方法执行时栈增长一样。这个分配对象的区域被称为年轻代/新生代（young generation）。当年轻代储存满了，垃圾收集器找到活跃的对象把它们拷贝到老年代（older generation）区域。一旦所有的存活对象拷贝完成，之前年轻代占用的内存就可以被回收了。因为老年代也是通过推进一个指针来分配内存的，拷贝得以迅速进行，这些对象使用的内存也被自动整理。另一个年轻代回收效率高的原因是，在实际中，大多数队形不会在初次回收中存活，因而并不需要被拷贝。

  装箱可能会导致缓存未命中，由此伤害Scala程序在JVM运行的性能。现代中央处理器（CPU）拥有多级静态随机访问缓存（SRAM），相比于动态随机访问内存（DRAM），SRAM存储数据少但是速度快。每个核心有用自己独立的一级（L1）和二级（L2）缓存。L1缓存离CPU最近，通常被划分为指令缓存和数据缓存。有的CPU有所有核心共享的三级（L3）缓存。L2缓存比L1缓存大，但是比L1缓存慢。L3缓存更大，但是比L2缓存慢。内存DRAM更大且比缓存更慢。从DRAM访问数据比从L1缓存访问数据要慢几个数量级，所以缓存未命中对性能的影响很大。

  对于任何存在垃圾回收的语言来说，分配内存时，会引入CPU自上个垃圾回收周期没有被访问过的内存，这一定会导致缓存未命中。每次分配内存，都会指向自上次垃圾回收以来从没有被用过的内存，因为使用过的内存是装满了对象的（可能大多是不活动的对象）。因此，当你从年轻代获取一块内存时，遭到缓存未命中。

  此外，当你运行了一个对象的方法，这个方法调用了另一个相关对象的不同的方法，CPU需要加载这个相关的对象。如果这个对象不在缓存中，你需要等待它从DRAM中取出。你有可能遭到带宽限制而等得更久。如果接下来还有更深层的对象访问，则又可能再次等待DRAM。你必须先等第一个对象取出，才能操作下一个对象。如果这段字节码是热点（经常被执行），JIT编译器会尝试把它们所有都移出堆而放到寄存器中。但是若不是这种情况，你就只能间接加载这些对象，等待内存响应。

  缓存未命中也意味着有些数据或指令需要配移出缓存，以便为从堆上分配的内存腾出空间。因此，除了承担从年轻代区域中获取新内存的成本之外，你可能还会在以后再次需要被驱逐出的内容时，付出缓存未命中的代价。

  与此相反，C语言程序通过malloc 和 free手动管理内存，不能简单推进指针分配内存。对于每次分配内存，malloc从堆中搜索未使用的区域，并且不小于所需要的大小。但是内存在不需要的时候肯伊被立即释放，新分配的内存空间可能仍在CPU缓存里。尽管搜索大小可用的区域其开销比推进指针的开销大，但它会被任何缓存未命中的成本所极大地抵消。。

  如果对象被频繁的分配内存，你就需要频繁刷新缓存，才能把对象分配的新内存带入，而这些对象往往寿命不长。垃圾回收的成本会很低，因为大多数对象在年轻代的第一次回收中就不会存活。总之，在一个有垃圾回收的语言中，装箱的主要成本是：1.分配内存时，可能需要持续刷新缓存来容纳新的对象，2.由间接引用导致的缓存未命中，3.由于缓存清理而移出、需要重新加载的对象
